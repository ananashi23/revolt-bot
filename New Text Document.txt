// bot.js - The "Final Race Winner" Version (With De-Duplication and Multiple Server Support)
import { chromium } from 'playwright';

// --- Configuration ---
const TARGET_SERVER_IDS = [
    "01JDKZ9Y7AEPQQDA7BVQA10DZ7",  // Original server (sends ticket number and .3)
    "01K7A7TBZ4SJKNXX47H9MHF6V7",  // Second server (sends .3)
    "01K7A7CNSMC5XPTJ7J36H9XKGR"   // New server (sends ticket number and .3)
];

console.log("--- Starting Revolt Bot (The 'Final Race Winner' Version with Multiple Server Support) ---");

// Helper function to generate a unique nonce
function generateNonce() {
    return Date.now().toString(36) + Math.random().toString(36).substring(2);
}

(async () => {
    const browser = await chromium.launch({ 
        headless: false,
        args: [
            '--disable-blink-features=AutomationControlled',
            '--disable-service-workers'
        ]
    });

    const context = await browser.newContext({
        viewport: { width: 1600, height: 900 },
        locale: 'en-US'
    });

    const page = await context.newPage();
    
    // Forward browser console logs to the Node.js terminal
    page.on('console', msg => {
        if (msg.type() === 'log') {
            console.log(msg.text());
        }
    });
    console.log("ðŸ”Š Listening for browser console messages...");

    // --- Part 0: Inject the DE-DUPLICATING bot logic ---
    console.log("ðŸ§  Injecting the de-duplicating bot logic...");
    await context.addInitScript(() => {
        console.log('[Bot Script] Logic injected. Initializing queue and de-duplicator...');
        
        // --- THE NEW DE-DUPLICATION SYSTEM ---
        window.processedChannelIds = new Set(); // Use a Set for fast lookups
        window.channelQueue = [];
        let isProcessing = false;

        window.processQueue = async () => {
            if (isProcessing || window.channelQueue.length === 0) {
                return;
            }

            isProcessing = true;
            const data = window.channelQueue.shift(); 
            console.log(`[Bot Script] Processing from queue. ${window.channelQueue.length} items remaining.`);

            const channelId = data._id;
            const channelName = data.name;
            const serverId = data.server;
            
            console.log(`[Bot Script] ðŸŽ¯ Channel: ${channelName}, Server: ${serverId}`);

            const apiChannelUrl = `https://revolt-api.onech.at/channels/${channelId}/messages`;
            
            try {
                // Check which server this channel belongs to and send appropriate messages
                if (serverId === "01JDKZ9Y7AEPQQDA7BVQA10DZ7" || serverId === "01K7A7CNSMC5XPTJ7J36H9XKGR") {
                    // Original server and new server: send ticket number and .3
                    const ticketNumberMatch = channelName.match(/\d+/);
                    const ticketNumber = ticketNumberMatch ? ticketNumberMatch[0] : channelName;
                    console.log(`[Bot Script] ðŸŽ« Ticket Number: ${ticketNumber}`);
                    
                    const payload1 = { content: ticketNumber, nonce: window.generateNonce(), replies: [] };
                    console.log(`[Bot Script] ðŸš€ Sending via Fetch: ${JSON.stringify(payload1)}`);
                    await fetch(apiChannelUrl, {
                        method: 'POST', headers: { 'Content-Type': 'application/json', 'x-session-token': window.authToken },
                        body: JSON.stringify(payload1)
                    });

                    const payload2 = { content: '.3', nonce: window.generateNonce(), replies: [] };
                    console.log(`[Bot Script] ðŸš€ Sending via Fetch: ${JSON.stringify(payload2)}`);
                    await fetch(apiChannelUrl, {
                        method: 'POST', headers: { 'Content-Type': 'application/json', 'x-session-token': window.authToken },
                        body: JSON.stringify(payload2)
                    });
                    
                    console.log(`[Bot Script] âœ… Successfully sent both messages for ${ticketNumber}.`);
                } else if (serverId === "01K7A7TBZ4SJKNXX47H9MHF6V7") {
                    // Second server: send .3 only
                    const payload = { content: '.3', nonce: window.generateNonce(), replies: [] };
                    console.log(`[Bot Script] ðŸš€ Sending via Fetch: ${JSON.stringify(payload)}`);
                    await fetch(apiChannelUrl, {
                        method: 'POST', headers: { 'Content-Type': 'application/json', 'x-session-token': window.authToken },
                        body: JSON.stringify(payload)
                    });
                    
                    console.log(`[Bot Script] âœ… Successfully sent .3 command.`);
                }

            } catch (error) {
                console.error(`[Bot Script] âŒ An error occurred during fetch: ${error.message}`);
            } finally {
                setTimeout(() => {
                    isProcessing = false;
                    window.processQueue();
                }, 50);
            }
        };

        const OriginalWebSocket = window.WebSocket;
        Object.defineProperty(window, 'WebSocket', {
            get() {
                return new Proxy(OriginalWebSocket, {
                    construct(target, args) {
                        const ws = new target(...args);
                        ws.addEventListener('message', (event) => {
                            if (isProcessing) return;
                            try {
                                const data = JSON.parse(event.data);
                                if (data.type === "ChannelCreate" && window.targetServerIds.includes(data.server)) {
                                    // --- THE DE-DUPLICATION CHECK ---
                                    if (window.processedChannelIds.has(data._id)) {
                                        console.log(`[Bot Script] Duplicate event for channel ${data._id}. Ignoring.`);
                                        return;
                                    }

                                    // Mark this channel ID as processed
                                    window.processedChannelIds.add(data._id);
                                    console.log('[Bot Script] New event detected! Adding to queue...');
                                    window.channelQueue.push(data);
                                    window.processQueue();
                                }
                            } catch (e) { /* Ignore parsing errors */ }
                        });
                        return ws;
                    }
                });
            },
            set() {
                console.warn('[Bot Script] Attempt to overwrite window.WebSocket was blocked.');
            }
        });
        console.log('[Bot Script] WebSocket proxy and de-duplicator are in place.');
    });
    
    // --- Part 1: Log in and fetch token ---
    await page.goto('https://revolt.onech.at');
    
    console.log("Please log in to your account now.");
    console.log("Once you are successfully logged in and can see the app, press ENTER in this terminal to ACTIVATE the bot.");
    
    await new Promise(resolve => process.stdin.once('data', resolve));
    
    console.log("âœ… Login confirmed. Fetching authentication token from IndexedDB...");

    const authToken = await page.evaluate(() => {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('localforage');
            request.onsuccess = () => {
                const db = request.result;
                const tx = db.transaction(['keyvaluepairs'], 'readonly');
                const store = tx.objectStore('keyvaluepairs');
                const getAllRequest = store.getAll();
                getAllRequest.onsuccess = () => {
                    const allValues = getAllRequest.result;
                    let foundToken = null;
                    for (const value of allValues) {
                        if (value && value.sessions) {
                            const sessionsObject = value.sessions;
                            const userIdKey = Object.keys(sessionsObject)[0];
                            if (userIdKey && sessionsObject[userIdKey] && sessionsObject[userIdKey].session) {
                                foundToken = sessionsObject[userIdKey].session.token;
                                break;
                            }
                        }
                    }
                    if (foundToken) {
                        resolve(foundToken);
                    } else {
                        reject(new Error('Could not find session token within any of the values in IndexedDB.'));
                    }
                };
                getAllRequest.onerror = () => reject(getAllRequest.error);
            };
            request.onerror = () => reject(request.error);
        });
    });

    if (authToken) {
        console.log(`âœ… Successfully fetched token!`);
    } else {
        console.error("âŒ Could not find token. The bot will not work.");
        return;
    }

    // --- Part 2: "Arm" the bot ---
    console.log("ðŸ” Arming the bot with token, server IDs, and helper function...");
    await page.evaluate(({ token, targetServerIds }) => {
        window.authToken = token;
        window.targetServerIds = targetServerIds;
        window.generateNonce = () => Date.now().toString(36) + Math.random().toString(36).substring(2);
        console.log('[Bot Script] Bot is ARMED and ready. De-duplicating listener is active.');
    }, { token: authToken, targetServerIds: TARGET_SERVER_IDS });

    console.log("ðŸš€ Bot is now running with DE-DUPLICATION enabled for multiple servers. Good luck!");
    
    // Keep the script running
    process.stdin.resume();
})();